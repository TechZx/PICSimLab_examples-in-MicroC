;  ASM code generated by mikroVirtualMachine for PIC - V. 8.0.0.0
;  Date/Time: 18-Jun-20 11:26:38 PM
;  Info: http://www.mikroe.com


; ADDRESS	OPCODE	ASM
; ----------------------------------------------
$0000	$EF6A	F002			GOTO	_main
$0008	$	_Delay_1us:
$0008	$0000	    			NOP
$000A	$0000	    			NOP
$000C	$0012	    			RETURN
$000E	$	_Delay_5500us:
$000E	$0E0F	    			MOVLW	15
$0010	$6E0B	    			MOVWF	STACK_11, 0
$0012	$0EFF	    			MOVLW	255
$0014	$6E0A	    			MOVWF	STACK_10, 0
$0016	$2E0B	    			DECFSZ	STACK_11, F, 0
$0018	$D001	    			BRA	$+2
$001A	$D003	    			BRA	$+4
$001C	$2E0A	    			DECFSZ	STACK_10, F, 0
$001E	$D7FE	    			BRA	$-1
$0020	$D7FA	    			BRA	$-5
$0022	$0E3E	    			MOVLW	62
$0024	$6E0A	    			MOVWF	STACK_10, 0
$0026	$2E0A	    			DECFSZ	STACK_10, F, 0
$0028	$D7FE	    			BRA	$-1
$002A	$0000	    			NOP
$002C	$0012	    			RETURN
$002E	$	_Delay_50us:
$002E	$0E21	    			MOVLW	33
$0030	$6E0A	    			MOVWF	STACK_10, 0
$0032	$2E0A	    			DECFSZ	STACK_10, F, 0
$0034	$D7FE	    			BRA	$-1
$0036	$0012	    			RETURN
$0038	$	SoftI2C_PutZerosToLAT:
$0038	$0E09	    			MOVLW	9
$003A	$5C15	    			SUBWF	___porti2c, 0, 0
$003C	$6EE1	    			MOVWF	FSR1L, 0
$003E	$0E0F	    			MOVLW	15
$0040	$6EE2	    			MOVWF	FSR1H, 0
$0042	$98E7	    			BCF	INDF1, ____sdai2c, 0
$0044	$96E7	    			BCF	INDF1, ____scli2c, 0
$0046	$0012	    			RETURN
$0048	$	_Lcd8_Cmd:
$0048	$C016	FFE9			MOVFF	Lcd8bit_main_global_dataAddress, FSR0L
$004C	$C017	FFEA			MOVFF	Lcd8bit_main_global_dataAddress+1, FSR0H
$0050	$C018	FFE1			MOVFF	Lcd8bit_main_global_ctrlAddress, FSR1L
$0054	$C019	FFE2			MOVFF	Lcd8bit_main_global_ctrlAddress+1, FSR1H
$0058	$6AEF	    			CLRF	INDF0, 0
$005A	$5279	    			MOVF	FARG_Lcd8_Cmd+0, 1, 0
$005C	$E000	    			BZ	L_Lcd8_Cmd_0
$005E	$	L_Lcd8_Cmd_0:
$005E	$BE79	    			BTFSC	FARG_Lcd8_Cmd+0, 7, 0
$0060	$8EEF	    			BSF	INDF0, __LCD8_DB7, 0
$0062	$BC79	    			BTFSC	FARG_Lcd8_Cmd+0, 6, 0
$0064	$8CEF	    			BSF	INDF0, __LCD8_DB6, 0
$0066	$BA79	    			BTFSC	FARG_Lcd8_Cmd+0, 5, 0
$0068	$8AEF	    			BSF	INDF0, __LCD8_DB5, 0
$006A	$B879	    			BTFSC	FARG_Lcd8_Cmd+0, 4, 0
$006C	$88EF	    			BSF	INDF0, __LCD8_DB4, 0
$006E	$B679	    			BTFSC	FARG_Lcd8_Cmd+0, 3, 0
$0070	$86EF	    			BSF	INDF0, __LCD8_DB3, 0
$0072	$B479	    			BTFSC	FARG_Lcd8_Cmd+0, 2, 0
$0074	$84EF	    			BSF	INDF0, __LCD8_DB2, 0
$0076	$B279	    			BTFSC	FARG_Lcd8_Cmd+0, 1, 0
$0078	$82EF	    			BSF	INDF0, __LCD8_DB1, 0
$007A	$B079	    			BTFSC	FARG_Lcd8_Cmd+0, 0, 0
$007C	$80EF	    			BSF	INDF0, __LCD8_DB0, 0
$007E	$501A	    			MOVF	Lcd8bit_main_global_cmd, 0, 0
$0080	$0A01	    			XORLW	1
$0082	$E103	    			BNZ	L_Lcd8_Cmd_1
$0084	$94E7	    			BCF	INDF1, __LCD8_RS, 0
$0086	$EF46	F000			GOTO	L_Lcd8_Cmd_2
$008A	$	L_Lcd8_Cmd_1:
$008A	$84E7	    			BSF	INDF1, __LCD8_RS, 0
$008C	$	L_Lcd8_Cmd_2:
$008C	$82E7	    			BSF	INDF1, __LCD8_ENABLE, 0
$008E	$EC04	F000			CALL	_Delay_1us
$0092	$92E7	    			BCF	INDF1, __LCD8_ENABLE, 0
$0094	$501A	    			MOVF	Lcd8bit_main_global_cmd, 0, 0
$0096	$0A01	    			XORLW	1
$0098	$E103	    			BNZ	L_Lcd8_Cmd_3
$009A	$EC07	F000			CALL	_Delay_5500us
$009E	$D002	    			BRA	L_Lcd8_Cmd_4
$00A0	$	L_Lcd8_Cmd_3:
$00A0	$EC17	F000			CALL	_Delay_50us
$00A4	$	L_Lcd8_Cmd_4:
$00A4	$0012	    			RETURN
$00A6	$	_read_keypad:
;part1.c,15 :: 			char  read_keypad()
;part1.c,19 :: 			PORTD = 0xFF;
$00A6	$0EFF	    			MOVLW	255
$00A8	$6E83	    			MOVWF	PORTD, 0
;part1.c,20 :: 			TRISD = 0xFF;    //configure PORT D as inpout
$00AA	$0EFF	    			MOVLW	255
$00AC	$6E95	    			MOVWF	TRISD, 0
;part1.c,22 :: 			TRISB = 0x00;     //configure PORT B as outpout
$00AE	$6A93	    			CLRF	TRISB, 0
;part1.c,23 :: 			PORTB = 0xFF;     //set all pins of PORT B to 1;
$00B0	$0EFF	    			MOVLW	255
$00B2	$6E81	    			MOVWF	PORTB, 0
;part1.c,25 :: 			key =0;
$00B4	$6A75	    			CLRF	read_keypad_key_L0, 0
;part1.c,26 :: 			do {                       //1-5 buttons
$00B6	$	L_read_keypad_0:
;part1.c,28 :: 			PORTB.F0 = 0;
$00B6	$9081	    			BCF	PORTB, 0, 0
;part1.c,29 :: 			delay_ms(10);
$00B8	$0E1A	    			MOVLW	26
$00BA	$6E0B	    			MOVWF	STACK_11, 0
$00BC	$0EFF	    			MOVLW	255
$00BE	$6E0A	    			MOVWF	STACK_10, 0
$00C0	$2E0B	    			DECFSZ	STACK_11, F, 0
$00C2	$D001	    			BRA	$+2
$00C4	$D003	    			BRA	$+4
$00C6	$2E0A	    			DECFSZ	STACK_10, F, 0
$00C8	$D7FE	    			BRA	$-1
$00CA	$D7FA	    			BRA	$-5
$00CC	$0EE7	    			MOVLW	231
$00CE	$6E0A	    			MOVWF	STACK_10, 0
$00D0	$2E0A	    			DECFSZ	STACK_10, F, 0
$00D2	$D7FE	    			BRA	$-1
$00D4	$0000	    			NOP
;part1.c,30 :: 			var = PORTD;
$00D6	$CF83	F074			MOVFF	PORTD, read_keypad_var_L0
;part1.c,32 :: 			if (var.F2 == 0) key = '4';
$00DA	$6A01	    			CLRF	STACK_1, 0
$00DC	$B474	    			BTFSC	read_keypad_var_L0, 2, 0
$00DE	$2A01	    			INCF	STACK_1, 1, 0
$00E0	$5001	    			MOVF	STACK_1, 0, 0
$00E2	$0A00	    			XORLW	0
$00E4	$E103	    			BNZ	L_read_keypad_2
$00E6	$0E34	    			MOVLW	52
$00E8	$6E75	    			MOVWF	read_keypad_key_L0, 0
$00EA	$D008	    			BRA	L_read_keypad_3
$00EC	$	L_read_keypad_2:
;part1.c,33 :: 			else if (var.F3 == 0) key = '1';
$00EC	$6A01	    			CLRF	STACK_1, 0
$00EE	$B674	    			BTFSC	read_keypad_var_L0, 3, 0
$00F0	$2A01	    			INCF	STACK_1, 1, 0
$00F2	$5001	    			MOVF	STACK_1, 0, 0
$00F4	$0A00	    			XORLW	0
$00F6	$E102	    			BNZ	L_read_keypad_4
$00F8	$0E31	    			MOVLW	49
$00FA	$6E75	    			MOVWF	read_keypad_key_L0, 0
$00FC	$	L_read_keypad_4:
$00FC	$	L_read_keypad_3:
;part1.c,34 :: 			PORTB.F0 =1;
$00FC	$8081	    			BSF	PORTB, 0, 0
;part1.c,37 :: 			PORTB.F1 = 0;
$00FE	$9281	    			BCF	PORTB, 1, 0
;part1.c,38 :: 			delay_ms(10);
$0100	$0E1A	    			MOVLW	26
$0102	$6E0B	    			MOVWF	STACK_11, 0
$0104	$0EFF	    			MOVLW	255
$0106	$6E0A	    			MOVWF	STACK_10, 0
$0108	$2E0B	    			DECFSZ	STACK_11, F, 0
$010A	$D001	    			BRA	$+2
$010C	$D003	    			BRA	$+4
$010E	$2E0A	    			DECFSZ	STACK_10, F, 0
$0110	$D7FE	    			BRA	$-1
$0112	$D7FA	    			BRA	$-5
$0114	$0EE7	    			MOVLW	231
$0116	$6E0A	    			MOVWF	STACK_10, 0
$0118	$2E0A	    			DECFSZ	STACK_10, F, 0
$011A	$D7FE	    			BRA	$-1
$011C	$0000	    			NOP
;part1.c,39 :: 			var = PORTD;
$011E	$CF83	F074			MOVFF	PORTD, read_keypad_var_L0
;part1.c,41 :: 			if (var.F2 == 0)key = '5';
$0122	$6A01	    			CLRF	STACK_1, 0
$0124	$B474	    			BTFSC	read_keypad_var_L0, 2, 0
$0126	$2A01	    			INCF	STACK_1, 1, 0
$0128	$5001	    			MOVF	STACK_1, 0, 0
$012A	$0A00	    			XORLW	0
$012C	$E103	    			BNZ	L_read_keypad_5
$012E	$0E35	    			MOVLW	53
$0130	$6E75	    			MOVWF	read_keypad_key_L0, 0
$0132	$D008	    			BRA	L_read_keypad_6
$0134	$	L_read_keypad_5:
;part1.c,42 :: 			else if (var.F3 == 0)key = '2';
$0134	$6A01	    			CLRF	STACK_1, 0
$0136	$B674	    			BTFSC	read_keypad_var_L0, 3, 0
$0138	$2A01	    			INCF	STACK_1, 1, 0
$013A	$5001	    			MOVF	STACK_1, 0, 0
$013C	$0A00	    			XORLW	0
$013E	$E102	    			BNZ	L_read_keypad_7
$0140	$0E32	    			MOVLW	50
$0142	$6E75	    			MOVWF	read_keypad_key_L0, 0
$0144	$	L_read_keypad_7:
$0144	$	L_read_keypad_6:
;part1.c,43 :: 			PORTB.F1 =1;
$0144	$8281	    			BSF	PORTB, 1, 0
;part1.c,46 :: 			PORTB.F2 =0;
$0146	$9481	    			BCF	PORTB, 2, 0
;part1.c,47 :: 			delay_ms(10);
$0148	$0E1A	    			MOVLW	26
$014A	$6E0B	    			MOVWF	STACK_11, 0
$014C	$0EFF	    			MOVLW	255
$014E	$6E0A	    			MOVWF	STACK_10, 0
$0150	$2E0B	    			DECFSZ	STACK_11, F, 0
$0152	$D001	    			BRA	$+2
$0154	$D003	    			BRA	$+4
$0156	$2E0A	    			DECFSZ	STACK_10, F, 0
$0158	$D7FE	    			BRA	$-1
$015A	$D7FA	    			BRA	$-5
$015C	$0EE7	    			MOVLW	231
$015E	$6E0A	    			MOVWF	STACK_10, 0
$0160	$2E0A	    			DECFSZ	STACK_10, F, 0
$0162	$D7FE	    			BRA	$-1
$0164	$0000	    			NOP
;part1.c,48 :: 			var = PORTD;
$0166	$CF83	F074			MOVFF	PORTD, read_keypad_var_L0
;part1.c,50 :: 			if (var.F3 == 0) key = '3';
$016A	$6A01	    			CLRF	STACK_1, 0
$016C	$B674	    			BTFSC	read_keypad_var_L0, 3, 0
$016E	$2A01	    			INCF	STACK_1, 1, 0
$0170	$5001	    			MOVF	STACK_1, 0, 0
$0172	$0A00	    			XORLW	0
$0174	$E102	    			BNZ	L_read_keypad_8
$0176	$0E33	    			MOVLW	51
$0178	$6E75	    			MOVWF	read_keypad_key_L0, 0
$017A	$	L_read_keypad_8:
;part1.c,51 :: 			PORTB.F2 =1;
$017A	$8481	    			BSF	PORTB, 2, 0
;part1.c,52 :: 			}while (key == 0);
$017C	$5075	    			MOVF	read_keypad_key_L0, 0, 0
$017E	$0A00	    			XORLW	0
$0180	$E09A	    			BZ	L_read_keypad_0
$0182	$	L_read_keypad_1:
;part1.c,54 :: 			return key;
$0182	$C075	F000			MOVFF	read_keypad_key_L0, STACK_0
;part1.c,55 :: 			}
$0186	$0012	    			RETURN
$0188	$	_function_numbers:
;part1.c,57 :: 			unsigned char function_numbers(unsigned char v)
;part1.c,59 :: 			switch(v)
$0188	$D00F	    			BRA	L_function_numbers_9
;part1.c,61 :: 			case 1:
$018A	$	L_function_numbers_11:
;part1.c,62 :: 			return 0x06;
$018A	$0E06	    			MOVLW	6
$018C	$6E00	    			MOVWF	STACK_0, 0
$018E	$0012	    			RETURN
;part1.c,63 :: 			case 2:
$0190	$	L_function_numbers_12:
;part1.c,64 :: 			return 0x5B;
$0190	$0E5B	    			MOVLW	91
$0192	$6E00	    			MOVWF	STACK_0, 0
$0194	$0012	    			RETURN
;part1.c,65 :: 			case 3:
$0196	$	L_function_numbers_13:
;part1.c,66 :: 			return 0x4F;
$0196	$0E4F	    			MOVLW	79
$0198	$6E00	    			MOVWF	STACK_0, 0
$019A	$0012	    			RETURN
;part1.c,67 :: 			case 4:
$019C	$	L_function_numbers_14:
;part1.c,68 :: 			return 0x66;
$019C	$0E66	    			MOVLW	102
$019E	$6E00	    			MOVWF	STACK_0, 0
$01A0	$0012	    			RETURN
;part1.c,69 :: 			case 5:
$01A2	$	L_function_numbers_15:
;part1.c,70 :: 			return 0x6D;
$01A2	$0E6D	    			MOVLW	109
$01A4	$6E00	    			MOVWF	STACK_0, 0
$01A6	$0012	    			RETURN
;part1.c,72 :: 			}
$01A8	$	L_function_numbers_9:
$01A8	$5074	    			MOVF	FARG_function_numbers+0, 0, 0
$01AA	$0A01	    			XORLW	1
$01AC	$E0EE	    			BZ	L_function_numbers_11
$01AE	$5074	    			MOVF	FARG_function_numbers+0, 0, 0
$01B0	$0A02	    			XORLW	2
$01B2	$E0EE	    			BZ	L_function_numbers_12
$01B4	$5074	    			MOVF	FARG_function_numbers+0, 0, 0
$01B6	$0A03	    			XORLW	3
$01B8	$E0EE	    			BZ	L_function_numbers_13
$01BA	$5074	    			MOVF	FARG_function_numbers+0, 0, 0
$01BC	$0A04	    			XORLW	4
$01BE	$E0EE	    			BZ	L_function_numbers_14
$01C0	$5074	    			MOVF	FARG_function_numbers+0, 0, 0
$01C2	$0A05	    			XORLW	5
$01C4	$E0EE	    			BZ	L_function_numbers_15
$01C6	$	L_function_numbers_10:
;part1.c,73 :: 			return 0;
$01C6	$6A00	    			CLRF	STACK_0, 0
;part1.c,74 :: 			}
$01C8	$0012	    			RETURN
$01CA	$	_Soft_I2C_Start:
$01CA	$C015	FFE9			MOVFF	___porti2c, FSR0L
$01CE	$0E0F	    			MOVLW	15
$01D0	$6EEA	    			MOVWF	FSR0H, 0
$01D2	$88EF	    			BSF	INDF0, ____sdai2c, 0
$01D4	$EC04	F000			CALL	_Delay_1us
$01D8	$86EF	    			BSF	INDF0, ____scli2c, 0
$01DA	$EC04	F000			CALL	_Delay_1us
$01DE	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$01E2	$98EF	    			BCF	INDF0, ____sdai2c, 0
$01E4	$EC04	F000			CALL	_Delay_1us
$01E8	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$01EC	$96EF	    			BCF	INDF0, ____scli2c, 0
$01EE	$0012	    			RETURN
$01F0	$	_Soft_I2C_Write:
$01F0	$0E01	    			MOVLW	1
$01F2	$6E76	    			MOVWF	Soft_I2C_Write_result_L0, 0
$01F4	$0E08	    			MOVLW	8
$01F6	$6E75	    			MOVWF	Soft_I2C_Write_temp_L0, 0
$01F8	$C015	FFE9			MOVFF	___porti2c, FSR0L
$01FC	$0E0F	    			MOVLW	15
$01FE	$6EEA	    			MOVWF	FSR0H, 0
$0200	$	L_Soft_I2C_Write_4:
$0200	$5275	    			MOVF	Soft_I2C_Write_temp_L0, 1, 0
$0202	$E022	    			BZ	L_Soft_I2C_Write_5
$0204	$EC04	F000			CALL	_Delay_1us
$0208	$EC04	F000			CALL	_Delay_1us
$020C	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$0210	$96EF	    			BCF	INDF0, ____scli2c, 0
$0212	$EC04	F000			CALL	_Delay_1us
$0216	$5274	    			MOVF	FARG_Soft_I2C_Write+0, 1, 0
$0218	$E000	    			BZ	L_Soft_I2C_Write_6
$021A	$	L_Soft_I2C_Write_6:
$021A	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$021E	$3674	    			RLCF	FARG_soft_i2c_write+0, F, 0
$0220	$A0D8	    			BTFSS	STATUS, 0, 0
$0222	$EF16	F001			GOTO	l_018
$0226	$88EF	    			BSF	INDF0, ____sdai2c, 0
$0228	$EF17	F001			GOTO	l_01C
$022C	$	l_018:
$022C	$98EF	    			BCF	INDF0, ____sdai2c, 0
$022E	$	l_01C:
$022E	$0000	    			NOP
$0230	$EC04	F000			CALL	_Delay_1us
$0234	$86EF	    			BSF	INDF0, ____scli2c, 0
$0236	$0E12	    			MOVLW	18
$0238	$5EE9	    			SUBWF	FSR0L, F, 0
$023A	$A6EF	    			BTFSS	INDF0, ____scli2c, 0
$023C	$EF1D	F001			GOTO	$-1
$0240	$0E12	    			MOVLW	18
$0242	$26E9	    			ADDWF	FSR0L, F, 0
$0244	$0675	    			DECF	Soft_I2C_Write_temp_L0, 1, 0
$0246	$D7DC	    			BRA	L_Soft_I2C_Write_4
$0248	$	L_Soft_I2C_Write_5:
$0248	$6A76	    			CLRF	Soft_I2C_Write_result_L0, 0
$024A	$EC04	F000			CALL	_Delay_1us
$024E	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$0252	$0000	    			NOP
$0254	$96EF	    			BCF	INDF0, ____scli2c, 0
$0256	$EC04	F000			CALL	_Delay_1us
$025A	$88EF	    			BSF	INDF0, ____sdai2c, 0
$025C	$EC04	F000			CALL	_Delay_1us
$0260	$EC04	F000			CALL	_Delay_1us
$0264	$5276	    			MOVF	Soft_I2C_Write_result_L0, 1, 0
$0266	$E000	    			BZ	L_Soft_I2C_Write_7
$0268	$	L_Soft_I2C_Write_7:
$0268	$86EF	    			BSF	INDF0, ____scli2c, 0
$026A	$0E12	    			MOVLW	18
$026C	$5EE9	    			SUBWF	FSR0L, F, 0
$026E	$A6EF	    			BTFSS	INDF0, ____scli2c, 0
$0270	$EF37	F001			GOTO	$-1
$0274	$6A76	    			CLRF	FLOC_soft_i2c_write+1, 0
$0276	$EC04	F000			CALL	_Delay_1us
$027A	$B8EF	    			BTFSC	INDF0, ____sdai2c, 0
$027C	$8076	    			BSF	FLOC_soft_i2c_write+1, 0, 0
$027E	$EC04	F000			CALL	_Delay_1us
$0282	$EC04	F000			CALL	_Delay_1us
$0286	$EC04	F000			CALL	_Delay_1us
$028A	$EC04	F000			CALL	_Delay_1us
$028E	$EC04	F000			CALL	_Delay_1us
$0292	$EC04	F000			CALL	_Delay_1us
$0296	$EC04	F000			CALL	_Delay_1us
$029A	$EC04	F000			CALL	_Delay_1us
$029E	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$02A2	$0E12	    			MOVLW	18
$02A4	$26E9	    			ADDWF	FSR0L, F, 0
$02A6	$96EF	    			BCF	INDF0, ____scli2c, 0
$02A8	$98EF	    			BCF	INDF0, ____sdai2c, 0
$02AA	$C076	F000			MOVFF	Soft_I2C_Write_result_L0, STACK_0
$02AE	$0012	    			RETURN
$02B0	$	_Soft_I2C_Read:
$02B0	$6A75	    			CLRF	Soft_I2C_Read_result_L0, 0
$02B2	$0E08	    			MOVLW	8
$02B4	$6E76	    			MOVWF	Soft_I2C_Read_temp_L0, 0
$02B6	$C015	FFE9			MOVFF	___porti2c, FSR0L
$02BA	$0E0F	    			MOVLW	15
$02BC	$6EEA	    			MOVWF	FSR0H, 0
$02BE	$	L_Soft_I2C_Read_0:
$02BE	$5276	    			MOVF	Soft_I2C_Read_temp_L0, 1, 0
$02C0	$E01C	    			BZ	L_Soft_I2C_Read_1
$02C2	$EC04	F000			CALL	_Delay_1us
$02C6	$0000	    			NOP
$02C8	$88EF	    			BSF	INDF0, ____sdai2c, 0
$02CA	$EC04	F000			CALL	_Delay_1us
$02CE	$5275	    			MOVF	Soft_I2C_Read_result_L0, 1, 0
$02D0	$E000	    			BZ	L_Soft_I2C_Read_2
$02D2	$	L_Soft_I2C_Read_2:
$02D2	$86EF	    			BSF	INDF0, ____scli2c, 0
$02D4	$0E12	    			MOVLW	18
$02D6	$5EE9	    			SUBWF	FSR0L, F, 0
$02D8	$A6EF	    			BTFSS	INDF0, ____scli2c, 0
$02DA	$EF6C	F001			GOTO	$-1
$02DE	$B8EF	    			BTFSC	INDF0, ____sdai2c, 0
$02E0	$80D8	    			BSF	STATUS, C, 0
$02E2	$A8EF	    			BTFSS	INDF0, ____sdai2c, 0
$02E4	$90D8	    			BCF	STATUS, C, 0
$02E6	$3675	    			RLCF	FLOC_soft_i2c_read+0, F, 0
$02E8	$EC04	F000			CALL	_Delay_1us
$02EC	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$02F0	$0E12	    			MOVLW	18
$02F2	$26E9	    			ADDWF	FSR0L, F, 0
$02F4	$96EF	    			BCF	INDF0, ____scli2c, 0
$02F6	$0676	    			DECF	Soft_I2C_Read_temp_L0, 1, 0
$02F8	$D7E2	    			BRA	L_Soft_I2C_Read_0
$02FA	$	L_Soft_I2C_Read_1:
$02FA	$88EF	    			BSF	INDF0, ____sdai2c, 0
$02FC	$EC04	F000			CALL	_Delay_1us
$0300	$5274	    			MOVF	FARG_Soft_I2C_Read+0, 1, 0
$0302	$E002	    			BZ	L_Soft_I2C_Read_3
$0304	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$0308	$	L_Soft_I2C_Read_3:
$0308	$5074	    			MOVF	FARG_soft_i2c_read+0, W, 0
$030A	$B4D8	    			BTFSC	STATUS, 2, 0
$030C	$EF89	F001			GOTO	L_07C
$0310	$98EF	    			BCF	INDF0, ____sdai2c, 0
$0312	$	L_07C:
$0312	$0000	    			NOP
$0314	$EC04	F000			CALL	_Delay_1us
$0318	$86EF	    			BSF	INDF0, ____scli2c, 0
$031A	$0E12	    			MOVLW	18
$031C	$5EE9	    			SUBWF	FSR0L, F, 0
$031E	$A6EF	    			BTFSS	INDF0, ____scli2c, 0
$0320	$EF8F	F001			GOTO	$-1
$0324	$0E12	    			MOVLW	18
$0326	$26E9	    			ADDWF	FSR0L, F, 0
$0328	$EC04	F000			CALL	_Delay_1us
$032C	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$0330	$96EF	    			BCF	INDF0, ____scli2c, 0
$0332	$EC04	F000			CALL	_Delay_1us
$0336	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$033A	$98EF	    			BCF	INDF0, ____sdai2c, 0
$033C	$C075	F000			MOVFF	Soft_I2C_Read_result_L0, STACK_0
$0340	$0012	    			RETURN
$0342	$	_Soft_I2C_Stop:
$0342	$C015	FFE9			MOVFF	___porti2c, FSR0L
$0346	$0E0F	    			MOVLW	15
$0348	$6EEA	    			MOVWF	FSR0H, 0
$034A	$EC1C	F000			CALL	SoftI2C_PutZerosToLAT
$034E	$98EF	    			BCF	INDF0, ____sdai2c, 0
$0350	$EC04	F000			CALL	_Delay_1us
$0354	$86EF	    			BSF	INDF0, ____scli2c, 0
$0356	$0E12	    			MOVLW	18
$0358	$5EE9	    			SUBWF	FSR0L, F, 0
$035A	$A6EF	    			BTFSS	INDF0, ____scli2c, 0
$035C	$EFAD	F001			GOTO	$-1
$0360	$0E12	    			MOVLW	18
$0362	$26E9	    			ADDWF	FSR0L, F, 0
$0364	$EC04	F000			CALL	_Delay_1us
$0368	$EC04	F000			CALL	_Delay_1us
$036C	$EC04	F000			CALL	_Delay_1us
$0370	$EC04	F000			CALL	_Delay_1us
$0374	$88EF	    			BSF	INDF0, ____sdai2c, 0
$0376	$EC04	F000			CALL	_Delay_1us
$037A	$0012	    			RETURN
$037C	$	_LCD8_Out:
$037C	$D00F	    			BRA	L_LCD8_Out_12
$037E	$	L_LCD8_Out_14:
$037E	$0E80	    			MOVLW	128
$0380	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0382	$D019	    			BRA	L_LCD8_Out_13
$0384	$	L_LCD8_Out_15:
$0384	$0EC0	    			MOVLW	192
$0386	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0388	$D016	    			BRA	L_LCD8_Out_13
$038A	$	L_LCD8_Out_16:
$038A	$0E94	    			MOVLW	148
$038C	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$038E	$D013	    			BRA	L_LCD8_Out_13
$0390	$	L_LCD8_Out_17:
$0390	$0ED4	    			MOVLW	212
$0392	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0394	$D010	    			BRA	L_LCD8_Out_13
$0396	$	L_LCD8_Out_18:
$0396	$0E80	    			MOVLW	128
$0398	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$039A	$D00D	    			BRA	L_LCD8_Out_13
$039C	$	L_LCD8_Out_12:
$039C	$5074	    			MOVF	FARG_LCD8_Out+0, 0, 0
$039E	$0A01	    			XORLW	1
$03A0	$E0EE	    			BZ	L_LCD8_Out_14
$03A2	$5074	    			MOVF	FARG_LCD8_Out+0, 0, 0
$03A4	$0A02	    			XORLW	2
$03A6	$E0EE	    			BZ	L_LCD8_Out_15
$03A8	$5074	    			MOVF	FARG_LCD8_Out+0, 0, 0
$03AA	$0A03	    			XORLW	3
$03AC	$E0EE	    			BZ	L_LCD8_Out_16
$03AE	$5074	    			MOVF	FARG_LCD8_Out+0, 0, 0
$03B0	$0A04	    			XORLW	4
$03B2	$E0EE	    			BZ	L_LCD8_Out_17
$03B4	$D7F0	    			BRA	L_LCD8_Out_18
$03B6	$	L_LCD8_Out_13:
$03B6	$0475	    			DECF	FARG_LCD8_Out+1, 0, 0
$03B8	$6E00	    			MOVWF	STACK_0, 0
$03BA	$5074	    			MOVF	FARG_LCD8_Out+0, 0, 0
$03BC	$2600	    			ADDWF	STACK_0, 1, 0
$03BE	$C000	F074			MOVFF	STACK_0, FARG_LCD8_Out+0
$03C2	$0E01	    			MOVLW	1
$03C4	$6E1A	    			MOVWF	Lcd8bit_main_global_cmd, 0
$03C6	$C000	F079			MOVFF	STACK_0, FARG_Lcd8_Cmd+0
$03CA	$EC24	F000			CALL	_Lcd8_Cmd
$03CE	$6A1A	    			CLRF	Lcd8bit_main_global_cmd, 0
$03D0	$6A78	    			CLRF	LCD8_Out_i_L0, 0
$03D2	$	L_LCD8_Out_19:
$03D2	$5078	    			MOVF	LCD8_Out_i_L0, 0, 0
$03D4	$2476	    			ADDWF	FARG_LCD8_Out+2, 0, 0
$03D6	$6EE9	    			MOVWF	FSR0L, 0
$03D8	$0E00	    			MOVLW	0
$03DA	$2077	    			ADDWFC	FARG_LCD8_Out+3, 0, 0
$03DC	$6EEA	    			MOVWF	FSR0L+1, 0
$03DE	$CFEE	F000			MOVFF	POSTINC0, STACK_0
$03E2	$5200	    			MOVF	STACK_0, 1, 0
$03E4	$E00C	    			BZ	L_LCD8_Out_20
$03E6	$5078	    			MOVF	LCD8_Out_i_L0, 0, 0
$03E8	$2476	    			ADDWF	FARG_LCD8_Out+2, 0, 0
$03EA	$6EE9	    			MOVWF	FSR0L, 0
$03EC	$0E00	    			MOVLW	0
$03EE	$2077	    			ADDWFC	FARG_LCD8_Out+3, 0, 0
$03F0	$6EEA	    			MOVWF	FSR0L+1, 0
$03F2	$CFEE	F079			MOVFF	POSTINC0, FARG_Lcd8_Cmd+0
$03F6	$EC24	F000			CALL	_Lcd8_Cmd
$03FA	$2A78	    			INCF	LCD8_Out_i_L0, 1, 0
$03FC	$D7EA	    			BRA	L_LCD8_Out_19
$03FE	$	L_LCD8_Out_20:
$03FE	$0E01	    			MOVLW	1
$0400	$6E1A	    			MOVWF	Lcd8bit_main_global_cmd, 0
$0402	$0012	    			RETURN
$0404	$	_I2C_Init:
$0404	$9CC7	    			BCF	SSPSTAT, 6, 0
$0406	$9EC7	    			BCF	SSPSTAT, 7, 0
$0408	$8894	    			BSF	TRISC, 4, 0
$040A	$8694	    			BSF	TRISC, 3, 0
$040C	$0E38	    			MOVLW	56
$040E	$6EC6	    			MOVWF	SSPCON1, 0
$0410	$0012	    			RETURN
$0412	$	_Soft_I2C_Init:
$0412	$C074	FFE9			MOVFF	FARG_Soft_I2C_Init+0, FSR0L
$0416	$C075	FFEA			MOVFF	FARG_Soft_I2C_Init+1, FSR0H
$041A	$0E12	    			MOVLW	18
$041C	$2474	    			ADDWF	FARG_Soft_I2C_Init+0, 0, 0
$041E	$6E00	    			MOVWF	STACK_0, 0
$0420	$C000	F015			MOVFF	STACK_0, ___porti2c
$0424	$C000	FFE9			MOVFF	STACK_0, FSR0L
$0428	$88EF	    			BSF	INDF0, ____sdai2c, 0
$042A	$86EF	    			BSF	INDF0, ____scli2c, 0
$042C	$0E12	    			MOVLW	18
$042E	$5EE9	    			SUBWF	FSR0L, 1, 0
$0430	$A6EF	    			BTFSS	INDF0, ____scli2c, 0
$0432	$EF18	F002			GOTO	$-1
$0436	$0012	    			RETURN
$0438	$	_Lcd8_Init:
$0438	$EC07	F000			CALL	_Delay_5500us
$043C	$EC07	F000			CALL	_Delay_5500us
$0440	$EC07	F000			CALL	_Delay_5500us
$0444	$C076	F016			MOVFF	FARG_Lcd8_Init+2, Lcd8bit_main_global_dataAddress
$0448	$C077	F017			MOVFF	FARG_Lcd8_Init+3, Lcd8bit_main_global_dataAddress+1
$044C	$C074	F018			MOVFF	FARG_Lcd8_Init+0, Lcd8bit_main_global_ctrlAddress
$0450	$C075	F019			MOVFF	FARG_Lcd8_Init+1, Lcd8bit_main_global_ctrlAddress+1
$0454	$C074	FFE9			MOVFF	FARG_Lcd8_Init+0, FSR0L
$0458	$C075	FFEA			MOVFF	FARG_Lcd8_Init+1, FSR0H
$045C	$90EF	    			BCF	INDF0, __LCD8_RW, 0
$045E	$C076	FFE1			MOVFF	FARG_Lcd8_Init+2, FSR1L
$0462	$C077	FFE2			MOVFF	FARG_Lcd8_Init+3, FSR1H
$0466	$6AE6	    			CLRF	POSTINC1, 0
$0468	$0E11	    			MOVLW	17
$046A	$24E1	    			ADDWF	FSR1L, 0, 0
$046C	$6E00	    			MOVWF	STACK_0, 0
$046E	$C000	FFE1			MOVFF	STACK_0, FSR1L
$0472	$6AE7	    			CLRF	INDF1, 0
$0474	$0E12	    			MOVLW	18
$0476	$5C00	    			SUBWF	STACK_0, 0, 0
$0478	$6EE1	    			MOVWF	FSR1L, 0
$047A	$0E12	    			MOVLW	18
$047C	$26E9	    			ADDWF	FSR0L, 1, 0
$047E	$92EF	    			BCF	INDF0, __LCD8_ENABLE, 0
$0480	$94EF	    			BCF	INDF0, __LCD8_RS, 0
$0482	$90EF	    			BCF	INDF0, __LCD8_RW, 0
$0484	$0E12	    			MOVLW	18
$0486	$5EE9	    			SUBWF	FSR0L, 1, 0
$0488	$94EF	    			BCF	INDF0, __LCD8_RS, 0
$048A	$92EF	    			BCF	INDF0, __LCD8_ENABLE, 0
$048C	$90EF	    			BCF	INDF0, __LCD8_RW, 0
$048E	$0E30	    			MOVLW	48
$0490	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$0492	$EC24	F000			CALL	_Lcd8_Cmd
$0496	$0E30	    			MOVLW	48
$0498	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$049A	$EC24	F000			CALL	_Lcd8_Cmd
$049E	$0E30	    			MOVLW	48
$04A0	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$04A2	$EC24	F000			CALL	_Lcd8_Cmd
$04A6	$0E38	    			MOVLW	56
$04A8	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$04AA	$EC24	F000			CALL	_Lcd8_Cmd
$04AE	$0E08	    			MOVLW	8
$04B0	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$04B2	$EC24	F000			CALL	_Lcd8_Cmd
$04B6	$0E01	    			MOVLW	1
$04B8	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$04BA	$EC24	F000			CALL	_Lcd8_Cmd
$04BE	$0E06	    			MOVLW	6
$04C0	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$04C2	$EC24	F000			CALL	_Lcd8_Cmd
$04C6	$0E0C	    			MOVLW	12
$04C8	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$04CA	$EC24	F000			CALL	_Lcd8_Cmd
$04CE	$0E01	    			MOVLW	1
$04D0	$6E1A	    			MOVWF	Lcd8bit_main_global_cmd, 0
$04D2	$0012	    			RETURN
$04D4	$	_main:
$04D4	$0E54	    			MOVLW	84
$04D6	$6E54	    			MOVWF	lstr1_part1+0, 0
$04D8	$0E69	    			MOVLW	105
$04DA	$6E55	    			MOVWF	lstr1_part1+1, 0
$04DC	$0E6D	    			MOVLW	109
$04DE	$6E56	    			MOVWF	lstr1_part1+2, 0
$04E0	$0E65	    			MOVLW	101
$04E2	$6E57	    			MOVWF	lstr1_part1+3, 0
$04E4	$0E3D	    			MOVLW	61
$04E6	$6E58	    			MOVWF	lstr1_part1+4, 0
$04E8	$6A59	    			CLRF	lstr1_part1+5, 0
$04EA	$0E3A	    			MOVLW	58
$04EC	$6E5A	    			MOVWF	lstr2_part1+0, 0
$04EE	$6A5B	    			CLRF	lstr2_part1+1, 0
$04F0	$0E20	    			MOVLW	32
$04F2	$6E5C	    			MOVWF	lstr3_part1+0, 0
$04F4	$6A5D	    			CLRF	lstr3_part1+1, 0
$04F6	$0E20	    			MOVLW	32
$04F8	$6E5E	    			MOVWF	lstr4_part1+0, 0
$04FA	$6A5F	    			CLRF	lstr4_part1+1, 0
$04FC	$0E20	    			MOVLW	32
$04FE	$6E60	    			MOVWF	lstr5_part1+0, 0
$0500	$6A61	    			CLRF	lstr5_part1+1, 0
$0502	$0E20	    			MOVLW	32
$0504	$6E62	    			MOVWF	lstr6_part1+0, 0
$0506	$6A63	    			CLRF	lstr6_part1+1, 0
$0508	$0E20	    			MOVLW	32
$050A	$6E64	    			MOVWF	lstr7_part1+0, 0
$050C	$6A65	    			CLRF	lstr7_part1+1, 0
$050E	$0E20	    			MOVLW	32
$0510	$6E66	    			MOVWF	lstr8_part1+0, 0
$0512	$6A67	    			CLRF	lstr8_part1+1, 0
$0514	$0E44	    			MOVLW	68
$0516	$6E68	    			MOVWF	lstr9_part1+0, 0
$0518	$0E61	    			MOVLW	97
$051A	$6E69	    			MOVWF	lstr9_part1+1, 0
$051C	$0E74	    			MOVLW	116
$051E	$6E6A	    			MOVWF	lstr9_part1+2, 0
$0520	$0E65	    			MOVLW	101
$0522	$6E6B	    			MOVWF	lstr9_part1+3, 0
$0524	$0E3D	    			MOVLW	61
$0526	$6E6C	    			MOVWF	lstr9_part1+4, 0
$0528	$6A6D	    			CLRF	lstr9_part1+5, 0
$052A	$0E2F	    			MOVLW	47
$052C	$6E6E	    			MOVWF	lstr10_part1+0, 0
$052E	$6A6F	    			CLRF	lstr10_part1+1, 0
$0530	$0E2F	    			MOVLW	47
$0532	$6E70	    			MOVWF	lstr11_part1+0, 0
$0534	$6A71	    			CLRF	lstr11_part1+1, 0
;part1.c,77 :: 			void main() {
;part1.c,83 :: 			keypressed = read_keypad();
$0536	$EC53	F000			CALL	_read_keypad
$053A	$C000	F072			MOVFF	STACK_0, main_keypressed_L0
;part1.c,86 :: 			TRISD = 0x00;  //Define PORTD to operate as outpout
$053E	$6A95	    			CLRF	TRISD, 0
;part1.c,87 :: 			TRISA = 0xFB;  // Define PORTA pin 2 as output.
$0540	$0EFB	    			MOVLW	251
$0542	$6E92	    			MOVWF	TRISA, 0
;part1.c,90 :: 			keypressed = keypressed - 0x30;
$0544	$0E30	    			MOVLW	48
$0546	$5E00	    			SUBWF	STACK_0, 1, 0
$0548	$C000	F072			MOVFF	STACK_0, main_keypressed_L0
;part1.c,92 :: 			PORTD = function_numbers(keypressed); //Write the appropriate combination of bits to PORTD
$054C	$C000	F074			MOVFF	STACK_0, FARG_function_numbers+0
$0550	$ECC4	F000			CALL	_function_numbers
$0554	$C000	FF83			MOVFF	STACK_0, PORTD
;part1.c,93 :: 			switch (function_numbers(keypressed))
$0558	$C072	F074			MOVFF	main_keypressed_L0, FARG_function_numbers+0
$055C	$ECC4	F000			CALL	_function_numbers
$0560	$C000	F073			MOVFF	STACK_0, FLOC_main+31
$0564	$D22E	    			BRA	L_main_16
;part1.c,95 :: 			case 0x06:
$0566	$	L_main_18:
;part1.c,97 :: 			TRISE = 0x00; // PORTE is output
$0566	$6A96	    			CLRF	TRISE, 0
;part1.c,98 :: 			TRISD = 0x00; // PORTD is output
$0568	$6A95	    			CLRF	TRISD, 0
;part1.c,99 :: 			I2C_Init(100000);
$056A	$0E14	    			MOVLW	20
$056C	$6EC8	    			MOVWF	SSPADD, 0
$056E	$EC02	F002			CALL	_I2C_Init
;part1.c,102 :: 			Soft_I2C_Config(&PORTC, 4, 3); //Use Port C pins 4 and 3
$0572	$0E82	    			MOVLW	PORTC
$0574	$6E74	    			MOVWF	FARG_Soft_I2C_Init+0, 0
$0576	$0E0F	    			MOVLW	@PORTC
$0578	$6E75	    			MOVWF	FARG_Soft_I2C_Init+1, 0
$057A	$EC09	F002			CALL	_Soft_I2C_Init
;part1.c,103 :: 			Soft_I2C_Start(); // Issue I2C start signal
$057E	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,104 :: 			Soft_I2C_Write(0xD0); // Send byte (device address + W)
$0582	$0ED0	    			MOVLW	208
$0584	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0586	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,105 :: 			Soft_I2C_Write(1); // Send byte (Location of minutes register)
$058A	$0E01	    			MOVLW	1
$058C	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$058E	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,106 :: 			Soft_I2C_Start(); // Issue I2C start signal
$0592	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,107 :: 			Soft_I2C_Write(0xD1); // Send byte (device address + R)
$0596	$0ED1	    			MOVLW	209
$0598	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$059A	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,108 :: 			tempm = Soft_I2C_Read(0); // Read data (NO ACK)
$059E	$6A74	    			CLRF	FARG_Soft_I2C_Read+0, 0
$05A0	$EC58	F001			CALL	_Soft_I2C_Read
$05A4	$C000	F01B			MOVFF	STACK_0, _tempm
;part1.c,109 :: 			Soft_I2C_Stop();
$05A8	$ECA1	F001			CALL	_Soft_I2C_Stop
;part1.c,110 :: 			minutes[0]=((tempm & 0x70)>>4)+0x30;
$05AC	$0E70	    			MOVLW	112
$05AE	$141B	    			ANDWF	_tempm, 0, 0
$05B0	$6E1C	    			MOVWF	_minutes, 0
$05B2	$321C	    			RRCF	_minutes, 1, 0
$05B4	$9E1C	    			BCF	_minutes, 7, 0
$05B6	$321C	    			RRCF	_minutes, 1, 0
$05B8	$9E1C	    			BCF	_minutes, 7, 0
$05BA	$321C	    			RRCF	_minutes, 1, 0
$05BC	$9E1C	    			BCF	_minutes, 7, 0
$05BE	$321C	    			RRCF	_minutes, 1, 0
$05C0	$9E1C	    			BCF	_minutes, 7, 0
$05C2	$0E30	    			MOVLW	48
$05C4	$261C	    			ADDWF	_minutes, 1, 0
;part1.c,111 :: 			minutes[1]= (tempm & 0x0F) +0x30;
$05C6	$0E0F	    			MOVLW	15
$05C8	$141B	    			ANDWF	_tempm, 0, 0
$05CA	$6E1D	    			MOVWF	_minutes+1, 0
$05CC	$0E30	    			MOVLW	48
$05CE	$261D	    			ADDWF	_minutes+1, 1, 0
;part1.c,114 :: 			Soft_I2C_Config(&PORTC, 4, 3); //Use Port C pins 4 and 3
$05D0	$0E82	    			MOVLW	PORTC
$05D2	$6E74	    			MOVWF	FARG_Soft_I2C_Init+0, 0
$05D4	$0E0F	    			MOVLW	@PORTC
$05D6	$6E75	    			MOVWF	FARG_Soft_I2C_Init+1, 0
$05D8	$EC09	F002			CALL	_Soft_I2C_Init
;part1.c,115 :: 			Soft_I2C_Start(); // Issue I2C start signal
$05DC	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,116 :: 			Soft_I2C_Write(0xD0); // Send byte (device address + W)
$05E0	$0ED0	    			MOVLW	208
$05E2	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$05E4	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,117 :: 			Soft_I2C_Write(2); // Send byte (Location of hours register)
$05E8	$0E02	    			MOVLW	2
$05EA	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$05EC	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,118 :: 			Soft_I2C_Start(); // Issue I2C start signal
$05F0	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,119 :: 			Soft_I2C_Write(0xD1); // Send byte (device address + R)
$05F4	$0ED1	    			MOVLW	209
$05F6	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$05F8	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,120 :: 			temph = Soft_I2C_Read(0); // Read data (NO ACK)
$05FC	$6A74	    			CLRF	FARG_Soft_I2C_Read+0, 0
$05FE	$EC58	F001			CALL	_Soft_I2C_Read
$0602	$C000	F01E			MOVFF	STACK_0, _temph
;part1.c,121 :: 			Soft_I2C_Stop();
$0606	$ECA1	F001			CALL	_Soft_I2C_Stop
;part1.c,122 :: 			hours[0]=((temph & 0x30)>>4)+0x30;
$060A	$0E30	    			MOVLW	48
$060C	$141E	    			ANDWF	_temph, 0, 0
$060E	$6E1F	    			MOVWF	_hours, 0
$0610	$321F	    			RRCF	_hours, 1, 0
$0612	$9E1F	    			BCF	_hours, 7, 0
$0614	$321F	    			RRCF	_hours, 1, 0
$0616	$9E1F	    			BCF	_hours, 7, 0
$0618	$321F	    			RRCF	_hours, 1, 0
$061A	$9E1F	    			BCF	_hours, 7, 0
$061C	$321F	    			RRCF	_hours, 1, 0
$061E	$9E1F	    			BCF	_hours, 7, 0
$0620	$0E30	    			MOVLW	48
$0622	$261F	    			ADDWF	_hours, 1, 0
;part1.c,123 :: 			hours[1]= (temph & 0x0F) +0x30;
$0624	$0E0F	    			MOVLW	15
$0626	$141E	    			ANDWF	_temph, 0, 0
$0628	$6E20	    			MOVWF	_hours+1, 0
$062A	$0E30	    			MOVLW	48
$062C	$2620	    			ADDWF	_hours+1, 1, 0
;part1.c,127 :: 			Soft_I2C_Config(&PORTC, 4, 3); //Use PortC pins 4 and 3
$062E	$0E82	    			MOVLW	PORTC
$0630	$6E74	    			MOVWF	FARG_Soft_I2C_Init+0, 0
$0632	$0E0F	    			MOVLW	@PORTC
$0634	$6E75	    			MOVWF	FARG_Soft_I2C_Init+1, 0
$0636	$EC09	F002			CALL	_Soft_I2C_Init
;part1.c,128 :: 			Soft_I2C_Start(); // Issue I2C start signal
$063A	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,129 :: 			Soft_I2C_Write(0xA2); // Send byte via I2C (Address of 24cO2)
$063E	$0EA2	    			MOVLW	162
$0640	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0642	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,130 :: 			Soft_I2C_Write(2); // Send byte (address of EEPROM location)
$0646	$0E02	    			MOVLW	2
$0648	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$064A	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,131 :: 			Soft_I2C_Write(hours); // Send data (data to be written)
$064E	$0E1F	    			MOVLW	_hours
$0650	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0652	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,132 :: 			Soft_I2C_Write(minutes); // Send data (data to be written)
$0656	$0E1C	    			MOVLW	_minutes
$0658	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$065A	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,133 :: 			Soft_I2C_Stop();
$065E	$ECA1	F001			CALL	_Soft_I2C_Stop
;part1.c,135 :: 			Soft_I2C_Start(); // Issue I2C start signal
$0662	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,136 :: 			Soft_I2C_Write(0xA2); // Send byte (device address + W)
$0666	$0EA2	    			MOVLW	162
$0668	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$066A	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,137 :: 			Soft_I2C_Write(2); // Send byte (EEPROM location to read from)
$066E	$0E02	    			MOVLW	2
$0670	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0672	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,138 :: 			Soft_I2C_Start(); // Issue I2C start signal
$0676	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,139 :: 			Soft_I2C_Write(0xA3); // Send byte (device address + R)
$067A	$0EA3	    			MOVLW	163
$067C	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$067E	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,140 :: 			mem_data[0] = Soft_I2C_Read(1); // Read data (send ACK)
$0682	$0E01	    			MOVLW	1
$0684	$6E74	    			MOVWF	FARG_Soft_I2C_Read+0, 0
$0686	$EC58	F001			CALL	_Soft_I2C_Read
$068A	$C000	F021			MOVFF	STACK_0, _mem_data
$068E	$0E00	    			MOVLW	0
$0690	$6E22	    			MOVWF	_mem_data+1, 0
;part1.c,141 :: 			mem_data[1] = Soft_I2C_Read(1); // Read data (send ACK)
$0692	$0E01	    			MOVLW	1
$0694	$6E74	    			MOVWF	FARG_Soft_I2C_Read+0, 0
$0696	$EC58	F001			CALL	_Soft_I2C_Read
$069A	$C000	F023			MOVFF	STACK_0, _mem_data+2
$069E	$0E00	    			MOVLW	0
$06A0	$6E24	    			MOVWF	_mem_data+3, 0
;part1.c,145 :: 			Soft_I2C_Config(&PORTC, 4, 3); //Use Port C pins 4 and 3
$06A2	$0E82	    			MOVLW	PORTC
$06A4	$6E74	    			MOVWF	FARG_Soft_I2C_Init+0, 0
$06A6	$0E0F	    			MOVLW	@PORTC
$06A8	$6E75	    			MOVWF	FARG_Soft_I2C_Init+1, 0
$06AA	$EC09	F002			CALL	_Soft_I2C_Init
;part1.c,146 :: 			Soft_I2C_Start(); // Issue I2C start signal
$06AE	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,147 :: 			Soft_I2C_Write(0xD0); // Send byte (device address + W)
$06B2	$0ED0	    			MOVLW	208
$06B4	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$06B6	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,148 :: 			Soft_I2C_Write(4); // Send byte (Location of day register)
$06BA	$0E04	    			MOVLW	4
$06BC	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$06BE	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,149 :: 			Soft_I2C_Start(); // Issue I2C start signal
$06C2	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,150 :: 			Soft_I2C_Write(0xD1); // Send byte (device address + R)
$06C6	$0ED1	    			MOVLW	209
$06C8	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$06CA	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,151 :: 			tempDay = Soft_I2C_Read(0); // Read data (NO ACK)
$06CE	$6A74	    			CLRF	FARG_Soft_I2C_Read+0, 0
$06D0	$EC58	F001			CALL	_Soft_I2C_Read
$06D4	$C000	F035			MOVFF	STACK_0, _tempDay
;part1.c,152 :: 			Soft_I2C_Stop();
$06D8	$ECA1	F001			CALL	_Soft_I2C_Stop
;part1.c,153 :: 			day[0]=((tempDay & 0x70)>>4)+0x30;
$06DC	$0E70	    			MOVLW	112
$06DE	$1435	    			ANDWF	_tempDay, 0, 0
$06E0	$6E36	    			MOVWF	_day, 0
$06E2	$3236	    			RRCF	_day, 1, 0
$06E4	$9E36	    			BCF	_day, 7, 0
$06E6	$3236	    			RRCF	_day, 1, 0
$06E8	$9E36	    			BCF	_day, 7, 0
$06EA	$3236	    			RRCF	_day, 1, 0
$06EC	$9E36	    			BCF	_day, 7, 0
$06EE	$3236	    			RRCF	_day, 1, 0
$06F0	$9E36	    			BCF	_day, 7, 0
$06F2	$0E30	    			MOVLW	48
$06F4	$2636	    			ADDWF	_day, 1, 0
;part1.c,154 :: 			day[1]= (tempDay & 0x0F) +0x30;
$06F6	$0E0F	    			MOVLW	15
$06F8	$1435	    			ANDWF	_tempDay, 0, 0
$06FA	$6E37	    			MOVWF	_day+1, 0
$06FC	$0E30	    			MOVLW	48
$06FE	$2637	    			ADDWF	_day+1, 1, 0
;part1.c,157 :: 			Soft_I2C_Config(&PORTC, 4, 3); //Use Port C pins 4 and 3
$0700	$0E82	    			MOVLW	PORTC
$0702	$6E74	    			MOVWF	FARG_Soft_I2C_Init+0, 0
$0704	$0E0F	    			MOVLW	@PORTC
$0706	$6E75	    			MOVWF	FARG_Soft_I2C_Init+1, 0
$0708	$EC09	F002			CALL	_Soft_I2C_Init
;part1.c,158 :: 			Soft_I2C_Start(); // Issue I2C start signal
$070C	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,159 :: 			Soft_I2C_Write(0xD0); // Send byte (device address + W)
$0710	$0ED0	    			MOVLW	208
$0712	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0714	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,160 :: 			Soft_I2C_Write(5); // Send byte (Location of month register)
$0718	$0E05	    			MOVLW	5
$071A	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$071C	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,161 :: 			Soft_I2C_Start(); // Issue I2C start signal
$0720	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,162 :: 			Soft_I2C_Write(0xD1); // Send byte (device address + R)
$0724	$0ED1	    			MOVLW	209
$0726	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0728	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,163 :: 			tempMonth = Soft_I2C_Read(0); // Read data (NO ACK)
$072C	$6A74	    			CLRF	FARG_Soft_I2C_Read+0, 0
$072E	$EC58	F001			CALL	_Soft_I2C_Read
$0732	$C000	F038			MOVFF	STACK_0, _tempMonth
;part1.c,164 :: 			Soft_I2C_Stop();
$0736	$ECA1	F001			CALL	_Soft_I2C_Stop
;part1.c,165 :: 			month[0]=((tempMonth & 0x30)>>4)+0x30;
$073A	$0E30	    			MOVLW	48
$073C	$1438	    			ANDWF	_tempMonth, 0, 0
$073E	$6E39	    			MOVWF	_month, 0
$0740	$3239	    			RRCF	_month, 1, 0
$0742	$9E39	    			BCF	_month, 7, 0
$0744	$3239	    			RRCF	_month, 1, 0
$0746	$9E39	    			BCF	_month, 7, 0
$0748	$3239	    			RRCF	_month, 1, 0
$074A	$9E39	    			BCF	_month, 7, 0
$074C	$3239	    			RRCF	_month, 1, 0
$074E	$9E39	    			BCF	_month, 7, 0
$0750	$0E30	    			MOVLW	48
$0752	$2639	    			ADDWF	_month, 1, 0
;part1.c,166 :: 			month[1]= (tempMonth & 0x0F) +0x30;
$0754	$0E0F	    			MOVLW	15
$0756	$1438	    			ANDWF	_tempMonth, 0, 0
$0758	$6E3A	    			MOVWF	_month+1, 0
$075A	$0E30	    			MOVLW	48
$075C	$263A	    			ADDWF	_month+1, 1, 0
;part1.c,169 :: 			Soft_I2C_Config(&PORTC, 4, 3); //Use Port C pins 4 and 3
$075E	$0E82	    			MOVLW	PORTC
$0760	$6E74	    			MOVWF	FARG_Soft_I2C_Init+0, 0
$0762	$0E0F	    			MOVLW	@PORTC
$0764	$6E75	    			MOVWF	FARG_Soft_I2C_Init+1, 0
$0766	$EC09	F002			CALL	_Soft_I2C_Init
;part1.c,170 :: 			Soft_I2C_Start(); // Issue I2C start signal
$076A	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,171 :: 			Soft_I2C_Write(0xD0); // Send byte (device address + W)
$076E	$0ED0	    			MOVLW	208
$0770	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0772	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,172 :: 			Soft_I2C_Write(6); // Send byte (Location of year register)
$0776	$0E06	    			MOVLW	6
$0778	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$077A	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,173 :: 			Soft_I2C_Start(); // Issue I2C start signal
$077E	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,174 :: 			Soft_I2C_Write(0xD1); // Send byte (device address + R)
$0782	$0ED1	    			MOVLW	209
$0784	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0786	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,175 :: 			tempYear = Soft_I2C_Read(0); // Read data (NO ACK)
$078A	$6A74	    			CLRF	FARG_Soft_I2C_Read+0, 0
$078C	$EC58	F001			CALL	_Soft_I2C_Read
$0790	$C000	F03B			MOVFF	STACK_0, _tempYear
;part1.c,176 :: 			Soft_I2C_Stop();
$0794	$ECA1	F001			CALL	_Soft_I2C_Stop
;part1.c,177 :: 			year[0]=((tempYear & 0x70)>>4)+0x30;
$0798	$0E70	    			MOVLW	112
$079A	$143B	    			ANDWF	_tempYear, 0, 0
$079C	$6E3C	    			MOVWF	_year, 0
$079E	$323C	    			RRCF	_year, 1, 0
$07A0	$9E3C	    			BCF	_year, 7, 0
$07A2	$323C	    			RRCF	_year, 1, 0
$07A4	$9E3C	    			BCF	_year, 7, 0
$07A6	$323C	    			RRCF	_year, 1, 0
$07A8	$9E3C	    			BCF	_year, 7, 0
$07AA	$323C	    			RRCF	_year, 1, 0
$07AC	$9E3C	    			BCF	_year, 7, 0
$07AE	$0E30	    			MOVLW	48
$07B0	$263C	    			ADDWF	_year, 1, 0
;part1.c,178 :: 			year[1]= (tempYear & 0x0F) +0x30;
$07B2	$0E0F	    			MOVLW	15
$07B4	$143B	    			ANDWF	_tempYear, 0, 0
$07B6	$6E3D	    			MOVWF	_year+1, 0
$07B8	$0E30	    			MOVLW	48
$07BA	$263D	    			ADDWF	_year+1, 1, 0
;part1.c,183 :: 			Soft_I2C_Config(&PORTC, 4, 3); //Use PortC pins 4 and 3
$07BC	$0E82	    			MOVLW	PORTC
$07BE	$6E74	    			MOVWF	FARG_Soft_I2C_Init+0, 0
$07C0	$0E0F	    			MOVLW	@PORTC
$07C2	$6E75	    			MOVWF	FARG_Soft_I2C_Init+1, 0
$07C4	$EC09	F002			CALL	_Soft_I2C_Init
;part1.c,184 :: 			Soft_I2C_Start(); // Issue I2C start signal
$07C8	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,185 :: 			Soft_I2C_Write(0xA2); // Send byte via I2C (Address of 24cO2)
$07CC	$0EA2	    			MOVLW	162
$07CE	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$07D0	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,186 :: 			Soft_I2C_Write(2); // Send byte (address of EEPROM location)
$07D4	$0E02	    			MOVLW	2
$07D6	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$07D8	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,187 :: 			Soft_I2C_Write(day); // Send data (data to be written)
$07DC	$0E36	    			MOVLW	_day
$07DE	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$07E0	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,189 :: 			Soft_I2C_Write(month); // Send data (data to be written)
$07E4	$0E39	    			MOVLW	_month
$07E6	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$07E8	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,190 :: 			Soft_I2C_Write(year); // Send data (data to be written)
$07EC	$0E3C	    			MOVLW	_year
$07EE	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$07F0	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,192 :: 			Soft_I2C_Stop();
$07F4	$ECA1	F001			CALL	_Soft_I2C_Stop
;part1.c,194 :: 			Soft_I2C_Start(); // Issue I2C start signal
$07F8	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,195 :: 			Soft_I2C_Write(0xA2); // Send byte (device address + W)
$07FC	$0EA2	    			MOVLW	162
$07FE	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0800	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,196 :: 			Soft_I2C_Write(2); // Send byte (EEPROM location to read from)
$0804	$0E02	    			MOVLW	2
$0806	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0808	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,197 :: 			Soft_I2C_Start(); // Issue I2C start signal
$080C	$ECE5	F000			CALL	_Soft_I2C_Start
;part1.c,198 :: 			Soft_I2C_Write(0xA3); // Send byte (device address + R)
$0810	$0EA3	    			MOVLW	163
$0812	$6E74	    			MOVWF	FARG_Soft_I2C_Write+0, 0
$0814	$ECF8	F000			CALL	_Soft_I2C_Write
;part1.c,199 :: 			mem2_data[0] = Soft_I2C_Read(1); // Read data (send ACK)
$0818	$0E01	    			MOVLW	1
$081A	$6E74	    			MOVWF	FARG_Soft_I2C_Read+0, 0
$081C	$EC58	F001			CALL	_Soft_I2C_Read
$0820	$C000	F040			MOVFF	STACK_0, _mem2_data
$0824	$0E00	    			MOVLW	0
$0826	$6E41	    			MOVWF	_mem2_data+1, 0
;part1.c,200 :: 			mem2_data[1] = Soft_I2C_Read(1); // Read data (send ACK)
$0828	$0E01	    			MOVLW	1
$082A	$6E74	    			MOVWF	FARG_Soft_I2C_Read+0, 0
$082C	$EC58	F001			CALL	_Soft_I2C_Read
$0830	$C000	F042			MOVFF	STACK_0, _mem2_data+2
$0834	$0E00	    			MOVLW	0
$0836	$6E43	    			MOVWF	_mem2_data+3, 0
;part1.c,201 :: 			mem2_data[2] = Soft_I2C_Read(1); // Read data (send ACK)
$0838	$0E01	    			MOVLW	1
$083A	$6E74	    			MOVWF	FARG_Soft_I2C_Read+0, 0
$083C	$EC58	F001			CALL	_Soft_I2C_Read
$0840	$C000	F044			MOVFF	STACK_0, _mem2_data+4
$0844	$0E00	    			MOVLW	0
$0846	$6E45	    			MOVWF	_mem2_data+5, 0
;part1.c,206 :: 			Lcd8_Config(&PORTE, &PORTD, 2,1,0, 7,6,5,4,3,2,1,0);
$0848	$0E84	    			MOVLW	PORTE
$084A	$6E74	    			MOVWF	FARG_Lcd8_Init+0, 0
$084C	$0E0F	    			MOVLW	@PORTE
$084E	$6E75	    			MOVWF	FARG_Lcd8_Init+1, 0
$0850	$0E83	    			MOVLW	PORTD
$0852	$6E76	    			MOVWF	FARG_Lcd8_Init+2, 0
$0854	$0E0F	    			MOVLW	@PORTD
$0856	$6E77	    			MOVWF	FARG_Lcd8_Init+3, 0
$0858	$EC1C	F002			CALL	_Lcd8_Init
;part1.c,207 :: 			Lcd8_Cmd(LCD_CURSOR_OFF); // Turn on blinking cursor
$085C	$0E0C	    			MOVLW	12
$085E	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$0860	$EC24	F000			CALL	_Lcd8_Cmd
;part1.c,208 :: 			Lcd8_Cmd(LCD_CLEAR);     // Clear screen
$0864	$0E01	    			MOVLW	1
$0866	$6E79	    			MOVWF	FARG_Lcd8_Cmd+0, 0
$0868	$EC24	F000			CALL	_Lcd8_Cmd
;part1.c,211 :: 			Lcd8_Out(1, 1,"Time=");
$086C	$0E01	    			MOVLW	1
$086E	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0870	$0E01	    			MOVLW	1
$0872	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$0874	$0E54	    			MOVLW	lstr1_part1
$0876	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$0878	$0E00	    			MOVLW	@lstr1_part1
$087A	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$087C	$ECBE	F001			CALL	_LCD8_Out
;part1.c,212 :: 			Lcd8_Out(1, 6,mem_data[0]);
$0880	$0E01	    			MOVLW	1
$0882	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0884	$0E06	    			MOVLW	6
$0886	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$0888	$C021	F076			MOVFF	_mem_data, FARG_LCD8_Out+2
$088C	$C022	F077			MOVFF	_mem_data+1, FARG_LCD8_Out+3
$0890	$ECBE	F001			CALL	_LCD8_Out
;part1.c,213 :: 			Lcd8_Out(1, 8,":") ;
$0894	$0E01	    			MOVLW	1
$0896	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0898	$0E08	    			MOVLW	8
$089A	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$089C	$0E5A	    			MOVLW	lstr2_part1
$089E	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$08A0	$0E00	    			MOVLW	@lstr2_part1
$08A2	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$08A4	$ECBE	F001			CALL	_LCD8_Out
;part1.c,214 :: 			Lcd8_Out(1, 9,mem_data[1]); // Print time on LCD
$08A8	$0E01	    			MOVLW	1
$08AA	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$08AC	$0E09	    			MOVLW	9
$08AE	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$08B0	$C023	F076			MOVFF	_mem_data+2, FARG_LCD8_Out+2
$08B4	$C024	F077			MOVFF	_mem_data+3, FARG_LCD8_Out+3
$08B8	$ECBE	F001			CALL	_LCD8_Out
;part1.c,216 :: 			Lcd8_Out(1, 11," ") ;
$08BC	$0E01	    			MOVLW	1
$08BE	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$08C0	$0E0B	    			MOVLW	11
$08C2	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$08C4	$0E5C	    			MOVLW	lstr3_part1
$08C6	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$08C8	$0E00	    			MOVLW	@lstr3_part1
$08CA	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$08CC	$ECBE	F001			CALL	_LCD8_Out
;part1.c,217 :: 			Lcd8_Out(1, 12," ") ;
$08D0	$0E01	    			MOVLW	1
$08D2	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$08D4	$0E0C	    			MOVLW	12
$08D6	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$08D8	$0E5E	    			MOVLW	lstr4_part1
$08DA	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$08DC	$0E00	    			MOVLW	@lstr4_part1
$08DE	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$08E0	$ECBE	F001			CALL	_LCD8_Out
;part1.c,218 :: 			Lcd8_Out(1, 13," ") ;
$08E4	$0E01	    			MOVLW	1
$08E6	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$08E8	$0E0D	    			MOVLW	13
$08EA	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$08EC	$0E60	    			MOVLW	lstr5_part1
$08EE	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$08F0	$0E00	    			MOVLW	@lstr5_part1
$08F2	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$08F4	$ECBE	F001			CALL	_LCD8_Out
;part1.c,219 :: 			Lcd8_Out(1, 14," ") ;
$08F8	$0E01	    			MOVLW	1
$08FA	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$08FC	$0E0E	    			MOVLW	14
$08FE	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$0900	$0E62	    			MOVLW	lstr6_part1
$0902	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$0904	$0E00	    			MOVLW	@lstr6_part1
$0906	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$0908	$ECBE	F001			CALL	_LCD8_Out
;part1.c,220 :: 			Lcd8_Out(1, 15," ") ;
$090C	$0E01	    			MOVLW	1
$090E	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0910	$0E0F	    			MOVLW	15
$0912	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$0914	$0E64	    			MOVLW	lstr7_part1
$0916	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$0918	$0E00	    			MOVLW	@lstr7_part1
$091A	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$091C	$ECBE	F001			CALL	_LCD8_Out
;part1.c,221 :: 			Lcd8_Out(1, 16," ") ;
$0920	$0E01	    			MOVLW	1
$0922	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0924	$0E10	    			MOVLW	16
$0926	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$0928	$0E66	    			MOVLW	lstr8_part1
$092A	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$092C	$0E00	    			MOVLW	@lstr8_part1
$092E	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$0930	$ECBE	F001			CALL	_LCD8_Out
;part1.c,223 :: 			Lcd8_Out(2, 1,"Date=");
$0934	$0E02	    			MOVLW	2
$0936	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0938	$0E01	    			MOVLW	1
$093A	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$093C	$0E68	    			MOVLW	lstr9_part1
$093E	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$0940	$0E00	    			MOVLW	@lstr9_part1
$0942	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$0944	$ECBE	F001			CALL	_LCD8_Out
;part1.c,224 :: 			Lcd8_Out(2, 6,mem2_data[0]);
$0948	$0E02	    			MOVLW	2
$094A	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$094C	$0E06	    			MOVLW	6
$094E	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$0950	$C040	F076			MOVFF	_mem2_data, FARG_LCD8_Out+2
$0954	$C041	F077			MOVFF	_mem2_data+1, FARG_LCD8_Out+3
$0958	$ECBE	F001			CALL	_LCD8_Out
;part1.c,225 :: 			Lcd8_Out(2, 8,"/") ;
$095C	$0E02	    			MOVLW	2
$095E	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0960	$0E08	    			MOVLW	8
$0962	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$0964	$0E6E	    			MOVLW	lstr10_part1
$0966	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$0968	$0E00	    			MOVLW	@lstr10_part1
$096A	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$096C	$ECBE	F001			CALL	_LCD8_Out
;part1.c,226 :: 			Lcd8_Out(2, 9,mem2_data[1]); // Print month on LCD
$0970	$0E02	    			MOVLW	2
$0972	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0974	$0E09	    			MOVLW	9
$0976	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$0978	$C042	F076			MOVFF	_mem2_data+2, FARG_LCD8_Out+2
$097C	$C043	F077			MOVFF	_mem2_data+3, FARG_LCD8_Out+3
$0980	$ECBE	F001			CALL	_LCD8_Out
;part1.c,227 :: 			Lcd8_Out(2, 11,"/") ;
$0984	$0E02	    			MOVLW	2
$0986	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$0988	$0E0B	    			MOVLW	11
$098A	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$098C	$0E70	    			MOVLW	lstr11_part1
$098E	$6E76	    			MOVWF	FARG_LCD8_Out+2, 0
$0990	$0E00	    			MOVLW	@lstr11_part1
$0992	$6E77	    			MOVWF	FARG_LCD8_Out+3, 0
$0994	$ECBE	F001			CALL	_LCD8_Out
;part1.c,228 :: 			Lcd8_Out(2, 12,mem2_data[2]); // Print year on LCD
$0998	$0E02	    			MOVLW	2
$099A	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$099C	$0E0C	    			MOVLW	12
$099E	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$09A0	$C044	F076			MOVFF	_mem2_data+4, FARG_LCD8_Out+2
$09A4	$C045	F077			MOVFF	_mem2_data+5, FARG_LCD8_Out+3
$09A8	$ECBE	F001			CALL	_LCD8_Out
;part1.c,229 :: 			Lcd8_Out(2, 14,mem2_data[2]); // Print year on LCD
$09AC	$0E02	    			MOVLW	2
$09AE	$6E74	    			MOVWF	FARG_LCD8_Out+0, 0
$09B0	$0E0E	    			MOVLW	14
$09B2	$6E75	    			MOVWF	FARG_LCD8_Out+1, 0
$09B4	$C044	F076			MOVFF	_mem2_data+4, FARG_LCD8_Out+2
$09B8	$C045	F077			MOVFF	_mem2_data+5, FARG_LCD8_Out+3
$09BC	$ECBE	F001			CALL	_LCD8_Out
;part1.c,230 :: 			}
$09C0	$D004	    			BRA	L_main_17
$09C2	$	L_main_16:
$09C2	$5073	    			MOVF	FLOC_main+31, 0, 0
$09C4	$0A06	    			XORLW	6
$09C6	$B4D8	    			BTFSC	STATUS, Z, 0
$09C8	$D5CE	    			BRA	L_main_18
$09CA	$	L_main_17:
;part1.c,231 :: 			}
$09CA	$D7FF	    			BRA	$
